<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>My Website</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { display: flex; }
    v-graph { flex: 1; }
  </style>
</head>
<body>
  <v-graph type="flow-chart"></v-graph>

  <script type="module">
    import { registerNode, registerLine } from './ui-graph.esm.js';
    import { data } from './flow-data.esm.js';

    function getAngle(x1, y1, x2, y2) {
        const deltaX = x2 - x1;
        const deltaY = y2 - y1;
        const angleRadians = Math.atan2(deltaY, deltaX);
        const angleDegrees = angleRadians * 180 / Math.PI;
        return angleDegrees;
    }

    registerLine('*', 'curve', {
      template: /*svg*/`
        <path d=""></path>
        <polygon points=""></polygon>
      `,
      style: /*css*/`
        svg { z-index: 99999; }
        g[type="curve"] > path {
            fill: none;
            stroke: #fafafa;
            stroke-width: 2px;
            transition: stroke 0.3s;
        }
        g[type="curve"] > path:hover {
            stroke: red;
        }
        g[type="curve"] > polygon {
            fill: #fafafa;
            stroke: #fafafa;
        }
      `,
      updateSVGPath($g, scale, info) {
        let cpx1 = 0; // 起始点的控制点上的 x 坐标
        let cpy1 = 0; // 起始点的控制点上的 y 坐标
        let cpx2 = 0; // 终点的控制点上的 x 坐标
        let cpy2 = 0; // 终点的控制点上的 y 坐标

        let ctx2 = info.x2;
        let cty2 = info.y2;

        if (info.d1 === 1) {
          cpx1 = info.x1;
          cpy1 = (info.y1 + info.y2) / 2;
        } else {
          cpx1 = (info.x1 + info.x2) / 2;
          cpy1 = info.y1;
        }
        if (info.d2 === 1) {
          cty2 -= 6;
          cpx2 = info.x2;
          cpy2 = (info.y1 + info.y2) / 2;
        } else {
          ctx2 -= 6;
          cpx2 = (info.x1 + info.x2) / 2;
          cpy2 = info.y2;
        }

        // 生成曲线的时候，如果是单向曲线，需要预留的最低宽度
        const cm = scale * 100;

        switch (info.r1) {
            case 'left':
                if (cpx1 - info.x1 > -cm) {
                    cpx1 = info.x1 - cm;
                }
                cpy1 = info.y1;
                break;
            case 'right':
                if (cpx1 - info.x1 < cm) {
                    cpx1 = info.x1 + cm;
                }
                cpy1 = info.y1;
                break;
            case 'down':
                if (cpy1 - info.y1 < cm) {
                    cpy1 = info.y1 + cm;
                }
                cpx1 = info.x1;
                break;
            case 'up':
                if (cpy1 - info.y1 > -cm) {
                    cpy1 = info.y1 - cm;
                }
                cpx1 = info.x1;
                break;
        }
        switch (info.r2) {
            case 'left':
                if (cpx2 - info.x2 > -cm) {
                    cpx2 = info.x2 - cm;
                }
                cpy2 = info.y2;
                break;
            case 'right':
                if (cpx2 - info.x2 < cm) {
                    cpx2 = info.x2 + cm;
                }
                cpy2 = info.y2;
                break;
            case 'down':
                if (cpy2 - info.y2 < cm) {
                    cpy2 = info.y2 + cm;
                }
                cpx2 = info.x2;
                break;
            case 'up':
                if (cpy2 - info.y2 > -cm) {
                    cpy2 = info.y2 - cm;
                }
                cpx2 = info.x2;
                break;
        }

        const $path = $g.querySelector(`path`);
        $path.setAttribute('d', `M${info.x1},${info.y1} C${cpx1},${cpy1} ${cpx2},${cpy2} ${ctx2},${cty2}`);

        const angle = getAngle(info.x2, info.y2, cpx2, cpy2);
        const c1x = info.x2; // 三角形顶点坐标
        const c1y = info.y2;

        const c2x = c1x + 4;
        const c2y = c1y - 6;

        const c3x = c1x - 4;
        const c3y = c1y - 6;

        const $polygon = $g.querySelector(`polygon`);
        $polygon.setAttribute('points', `${c1x},${c1y} ${c2x},${c2y} ${c3x},${c3y}`);
        $polygon.setAttribute('style', `transform-origin: ${c1x}px ${c1y}px; transform: rotate(${angle + 90}deg)`);
      },
    });

    registerNode('flow-chart', 'node', {
      template: /*html*/`
        <section class="content"></section>
      `,

      style: /*css*/`
        :host {
          background: #2b2b2bcc;
          border: 1px solid #333;
          border-radius: 4px;
          color: #ccc;
          transition: box-shadow 0.2s, border 0.2s;
        }
        :host(:hover) {
          border-color: white;
          box-shadow: 0px 0px 14px 2px white;
        }
        section {
          min-height: 20px;
          border: 1px solid #999;
          border-radius: 4px;
          padding: 4px 10px;
          text-align: center;
        }
      `,

      onInit(details) {
        const updateHTML = (HTML) => {
          this.querySelector(`.content`).innerHTML = HTML;
        }
        this.data.addPropertyListener('details', (details) => {
          updateHTML(details.label);
        });
        updateHTML(details.label);

        this.addEventListener('connect-line', (event) => {
          event.stopPropagation();
          event.preventDefault();
          const { node, param, paramDirection } = event.detail;
          this.methods.startConnect('curve', param, paramDirection);
        });
      },

      onMounted() {},

      onRemoved() {},
    });

    const $graph = document.querySelector('v-graph');
    for (let key in data) {
      $graph.data.setProperty(key, data[key]);
    }
  </script>
</body>
</html>